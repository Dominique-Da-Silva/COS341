PROG ::= main GLOBVARS ALGO FUNCTIONS

GLOBVARS ::= // nullable
GLOBVARS ::= VTYP VNAME , GLOBVARS

VTYP ::= num
VTYP ::= text

VNAME ::= a token of Token-Class V from the Lexer

ALGO ::= begin INSTRUC end

INSTRUC ::= // nullable
INSTRUC ::= COMMAND ; INSTRUC

COMMAND ::= skip
COMMAND ::= halt
COMMAND ::= print ATOMIC
COMMAND ::= ASSIGN
COMMAND ::= CALL
COMMAND ::= BRANCH
COMMAND ::= return ATOMIC // Added this new rule

ATOMIC ::= VNAME
ATOMIC ::= CONST

CONST ::= a token of Token-Class N from the Lexer
CONST ::= a token of Token-Class T from the Lexer

ASSIGN ::= VNAME < input
ASSIGN ::= VNAME = TERM

CALL ::= FNAME( ATOMIC , ATOMIC , ATOMIC )

BRANCH ::= if COND then ALGO else ALGO

TERM ::= ATOMIC
TERM ::= CALL
TERM ::= OP

OP ::= UNOP( ARG )
OP ::= BINOP( ARG , ARG )

ARG ::= ATOMIC
ARG ::= OP

COND ::= SIMPLE
COND ::= COMPOSIT

SIMPLE ::= BINOP( ATOMIC , ATOMIC )
COMPOSIT ::= BINOP( SIMPLE , SIMPLE )
COMPOSIT ::= UNOP( SIMPLE )

UNOP ::= not
UNOP ::= sqrt

BINOP ::= or
BINOP ::= and
BINOP ::= eq
BINOP ::= grt
BINOP ::= add
BINOP ::= sub
BINOP ::= mul
BINOP ::= div

FNAME ::= a token of Token-Class F from the Lexer

FUNCTIONS ::= // nullable
FUNCTIONS ::= DECL FUNCTIONS

DECL ::= HEADER BODY

HEADER ::= FTYP FNAME( VNAME , VNAME , VNAME )

FTYP ::= num
FTYP ::= void

BODY ::= PROLOG LOCVARS ALGO EPILOG SUBFUNCS end

PROLOG ::= {
EPILOG ::= }

LOCVARS ::= VTYP VNAME , VTYP VNAME , VTYP VNAME ,

SUBFUNCS ::= FUNCTIONS
